# Custom networks for service isolation
networks:
  media_network:
    driver: bridge
    ipam:
      config:
        - subnet: ${MEDIA_NETWORK_SUBNET}
  vpn_network:
    driver: bridge
    ipam:
      config:
        - subnet: ${VPN_NETWORK_SUBNET}
# Logging configuration
x-logging: &default-logging
  driver: json-file
  options:
    max-size: ${LOG_MAX_SIZE:-10m}
    max-file: ${LOG_MAX_FILE:-3}
# Using local directories instead of Docker volumes for easier management
services:
  # Directory initialization - ensures proper ownership before other services start
  init-directories:
    image: alpine:latest
    container_name: ${CONTAINER_PREFIX}init-directories
    user: "0:0" # Run as root to fix ownership
    command: >
      sh -c "






        mkdir -p /data/media/tv /data/media/movies /data/downloads/complete /data/downloads/incomplete /data/downloads/watch &&
        chown -R $(id -u):$(id -g) /data/ &&
        echo 'Directory ownership initialized: $(id -un):$(id -gn) ($(id -u):$(id -g))'
      "

    volumes:
      - ./data:/data
    restart: "no"
  # VPN Service - Modular provider system
  # Default: Cloudflare WARP (no credentials needed)
  # To use PIA: Set VPN_PROVIDER=pia in .env file and provide PIA credentials
  vpn:
    build:
      context: .
      dockerfile: dockerfiles/vpn/Dockerfile.${VPN_PROVIDER:-warp}
    container_name: ${CONTAINER_PREFIX}vpn
    env_file:
      - .env
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
      - NET_RAW
      - SYS_ADMIN # Required for network buffer sysctl modifications
    privileged: true # Required for iptables and routing setup
    user: "root"
    ports:
      - "${VPN_BITTORRENT_PORT:-16881}:6881" # qBittorrent BitTorrent port
      - "${VPN_BITTORRENT_PORT:-16881}:6881/udp" # qBittorrent BitTorrent port UDP
    environment:
      - VPN_PROVIDER=${VPN_PROVIDER:-warp}
      - WARP_SLEEP=2
      - TZ=${TZ:-America/New_York}
      # PIA-specific environment variables (ignored if not using PIA)
      - USER=${PIA_USER:-}
      - PASS=${PIA_PASS:-}
      - LOC=${PIA_REGION:-us_atlanta}
      - PORTFORWARD=${PORT_FORWARDING:-1}
      - LOCAL_NETWORK=${LOCAL_NETWORK:-192.168.1.0/24}
      - KEEPALIVE=25
      # WARP-specific environment variables (ignored if not using WARP)
      - WARP_LICENSE_KEY=${WARP_LICENSE_KEY:-}
    networks:
      default:
      vpn_network:
        ipv4_address: ${VPN_IP_ADDRESS}
    volumes:
      - ./setup-vpn-routing.sh:/usr/local/bin/setup-vpn-routing.sh:ro
      - ./scripts/qbittorrent-internal-monitor.sh:/scripts/qbittorrent-internal-monitor.sh:ro
      # PIA-specific volume for config storage
      - ./config/vpn:/config
    ulimits:
      nofile: ${VPN_MAX_FILE_DESCRIPTORS:-32768}
      memlock: -1
    sysctls:
      - net.ipv6.conf.all.disable_ipv6=0
      - net.ipv4.conf.all.src_valid_mark=1
      - net.ipv4.ip_forward=1
    deploy:
      resources:
        limits:
          memory: ${VPN_MEMORY_LIMIT:-1g}
    healthcheck:
      test: ["CMD-SHELL", "/scripts/vpn/${VPN_PROVIDER:-warp}/healthcheck.sh"]
      interval: ${VPN_HEALTH_CHECK_INTERVAL:-30s}
      timeout: 10s
      retries: 3
      start_period: 90s
    restart: unless-stopped
  # FlareSolverr - CloudFlare bypass proxy for Prowlarr indexers
  flaresolverr:
    image: ghcr.io/flaresolverr/flaresolverr:latest
    container_name: ${CONTAINER_PREFIX}flaresolverr
    networks:
      - media_network
    ports:
      - "${FLARESOLVERR_PORT:-18191}:8191"
    depends_on:
      vpn:
        condition: service_healthy
    environment:
      - LOG_LEVEL=info
      - TZ=${TZ:-America/New_York}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8191/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    stop_grace_period: 30s
  # qBittorrent - Torrent download client running through VPN
  qbittorrent:
    image: qbittorrentofficial/qbittorrent-nox:latest
    container_name: ${CONTAINER_PREFIX}qbittorrent
    network_mode: "container:${CONTAINER_PREFIX}vpn" # Share VPN container's network stack (most secure isolation)
    # Port removed - access through Web-UI proxy only
    depends_on:
      init-directories:
        condition: service_completed_successfully
      vpn:
        condition: service_healthy
    environment:
      - TZ=${TZ:-America/New_York}
      - QBT_WEBUI_PORT=${QBITTORRENT_INTERNAL_PORT:-8080}
      - QBT_LEGAL_NOTICE=confirm
      - QBITTORRENT_USERNAME=${QBITTORRENT_USERNAME:-admin}
      - QBITTORRENT_PORT=${QBITTORRENT_PORT:-6881}
    volumes:
      - ./config/qbittorrent:/config
      - ./config/templates/qbittorrent:/templates:ro
      - ./data/downloads:/downloads
      - ./data:/data
      - ./scripts:/scripts:ro
      - ./scripts/qbittorrent-internal-monitor.sh:/scripts/qbittorrent-internal-monitor.sh:ro
      - ./scripts/qbittorrent-wrapper-with-monitor.sh:/scripts/qbittorrent-wrapper-with-monitor.sh:ro
    entrypoint: ["/scripts/qbittorrent-entrypoint.sh"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${QBITTORRENT_INTERNAL_PORT:-8080}"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    profiles:
      - qbittorrent
    restart: unless-stopped
    stop_grace_period: 60s
  # Transmission - Alternative torrent download client running through VPN
  transmission:
    image: lscr.io/linuxserver/transmission:latest
    container_name: ${CONTAINER_PREFIX}transmission
    network_mode: "container:${CONTAINER_PREFIX}vpn" # Share VPN container's network stack (most secure isolation)
    depends_on:
      init-directories:
        condition: service_completed_successfully
      vpn:
        condition: service_healthy
    environment:
      - PUID=$(id -u)
      - PGID=$(id -g)
      - TZ=${TZ:-America/New_York}
      - USER=${TRANSMISSION_USERNAME}
      - PASS=${TRANSMISSION_PASSWORD}
      - PEERPORT=${TRANSMISSION_PORT:-51413}
    volumes:
      - ./config/transmission:/config
      - ./config/templates/transmission:/templates:ro
      - ./data/downloads:/downloads
      - ./data/downloads/watch:/watch
      - ./scripts:/scripts:ro
    entrypoint: ["/scripts/transmission-entrypoint.sh"]
    healthcheck:
      test: ["CMD", "sh", "-c", "curl -s http://localhost:9091/transmission/rpc | grep -q 'X-Transmission-Session-Id'"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    profiles:
      - transmission
    restart: unless-stopped
    stop_grace_period: 60s
  # Plex Media Server
  plex:
    image: ghcr.io/linuxserver/plex
    container_name: ${CONTAINER_PREFIX}plex
    network_mode: host # Required for discovery and direct play
    depends_on:
      init-directories:
        condition: service_completed_successfully
    environment:
      - PUID=$(id -u)
      - PGID=$(id -g)
      - TZ=${TZ:-America/New_York}
      - PLEX_CLAIM=${PLEX_CLAIM_TOKEN}
    volumes:
      - ./config/plex:/config
      - ./config/templates/plex:/templates:ro
      - ${MEDIA_ROOT:-./data/media}:/media
      - ${DOWNLOADS_ROOT:-./data/downloads}:/downloads
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:32400/identity"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
  # Jellyfin Media Server - Open source alternative to Plex
  jellyfin:
    image: ghcr.io/linuxserver/jellyfin:latest
    container_name: ${CONTAINER_PREFIX}jellyfin
    entrypoint: ["/scripts/jellyfin-entrypoint.sh"]
    networks:
      - media_network
    ports:
      - "${JELLYFIN_PORT:-8096}:8096"
      - "8920:8920" # HTTPS port (optional)
      - "7359:7359/udp" # Client discovery
      - "1900:1900/udp" # DLNA
    depends_on:
      init-directories:
        condition: service_completed_successfully
    env_file:
      - .env
    environment:
      - PUID=$(id -u)
      - PGID=$(id -g)
      - TZ=${TZ:-America/New_York}
      - JELLYFIN_PublishedServerUrl=http://localhost:8096
    volumes:
      - ./config/jellyfin:/config
      - ./config/templates/jellyfin:/templates:ro
      - ./scripts:/scripts:ro
      - ${MEDIA_ROOT}/movies:/data/movies:ro
      - ${MEDIA_ROOT}/tv:/data/tvshows:ro
      - ${DOWNLOADS_ROOT:-./data/downloads}:/downloads:ro
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8096/web/index.html"]
      interval: 60s
      timeout: 15s
      retries: 5
      start_period: 300s
    restart: unless-stopped
    stop_grace_period: 60s
  # Sonarr - TV Series Management
  sonarr:
    image: ghcr.io/linuxserver/sonarr
    container_name: ${CONTAINER_PREFIX}sonarr
    entrypoint: ["/scripts/sonarr-entrypoint.sh"]
    networks:
      - media_network
      - vpn_network
    ports:
      - "${SONARR_PORT:-8989}:8989"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      prowlarr:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=$(id -u)
      - PGID=$(id -g)
      - TZ=${TZ:-America/New_York}
    volumes:
      - ./config/sonarr:/config
      - ./config/templates/sonarr:/templates:ro
      - ./scripts:/scripts:ro
      - ${MEDIA_ROOT:-./data/media}/tv:/tv
      - ./data/downloads:/downloads
    healthcheck:
      test: ["CMD-SHELL", "curl -s http://localhost:8989 > /dev/null 2>&1 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 180s
    restart: unless-stopped
    stop_grace_period: 60s
  # Radarr - Movie Management
  radarr:
    image: ghcr.io/linuxserver/radarr
    container_name: ${CONTAINER_PREFIX}radarr
    entrypoint: ["/scripts/radarr-entrypoint.sh"]
    networks:
      - media_network
      - vpn_network
    ports:
      - "${RADARR_PORT:-7878}:7878"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      prowlarr:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=$(id -u)
      - PGID=$(id -g)
      - TZ=${TZ:-America/New_York}
    volumes:
      - ./config/radarr:/config
      - ./config/templates/radarr:/templates:ro
      - ./scripts:/scripts:ro
      - ${MEDIA_ROOT:-./data/media}/movies:/movies
      - ./data/downloads:/downloads
    healthcheck:
      test: ["CMD-SHELL", "curl -s http://localhost:7878 > /dev/null 2>&1 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 180s
    restart: unless-stopped
    stop_grace_period: 60s
  # Nginx Reverse Proxy - Secure bridge for accessing isolated services
  nginx-proxy:
    image: nginx:alpine
    container_name: ${CONTAINER_PREFIX}nginx-proxy
    networks:
      - media_network
      - vpn_network
    ports:
      - "${NGINX_QBITTORRENT_PORT:-8080}:8080" # qBittorrent proxy
      - "${NGINX_TRANSMISSION_PORT:-9091}:9091" # Transmission proxy
    volumes:
      - ./config/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped
  # Watchlistarr - Plex Watchlist Sync Service
  watchlistarr:
    image: ghcr.io/dabstractor/watchlistarr:latest
    container_name: ${CONTAINER_PREFIX}watchlistarr
    restart: unless-stopped
    networks:
      - media_network
    extra_hosts:
      - "docker-host:host-gateway"
    depends_on:
      sonarr:
        condition: service_healthy
      radarr:
        condition: service_healthy
      plex:
        condition: service_healthy
    environment:
      - PUID=$(id -u)
      - PGID=$(id -g)
      - TZ=${TZ:-America/New_York}
      - PLEX_HOST=${PLEX_HOST}
      - PLEX_PORT=${PLEX_PORT:-32400}
      - PLEX_TOKEN=${PLEX_TOKEN}
      - PLEX_USERNAME=${PLEX_USERNAME}
      - PLEX_PASSWORD=${PLEX_PASSWORD}
      - SONARR_API_KEY=${SONARR_API_KEY}
      - SONARR_BASE_URL=http://sonarr:8989
      - RADARR_API_KEY=${RADARR_API_KEY}
      - RADARR_BASE_URL=http://radarr:7878
    volumes:
      - ./config/watchlistarr:/app/config
      - ./config/templates/watchlistarr:/templates:ro
      - ./scripts:/scripts:ro
      - ./config/plex:/plex-config:ro
    entrypoint: ["/scripts/watchlistarr-entrypoint.sh"]
    healthcheck:
      test: ["CMD", "test", "-f", "/app/config/config.yaml"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    stop_grace_period: 30s
  # Web UI - React frontend for managing the entire stack
  web-ui:
    build: ./web-ui
    container_name: ${CONTAINER_PREFIX}web-ui
    networks:
      - media_network
      - vpn_network
    ports:
      - "${WEB_UI_PORT:-18787}:3000"
    # Run as current user to match file ownership
    user: "$(id -u):$(id -g)"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      vpn:
        condition: service_healthy
      plex:
        condition: service_healthy
      prowlarr:
        condition: service_healthy
    environment:
      - NODE_ENV=production
      - PORT=3000
      - WEB_UI_PORT=${WEB_UI_PORT:-18787}
      - NEXT_TELEMETRY_DISABLED=1
      # Frontend URLs for the Services page (user browser access)
      - PROWLARR_URL=http://localhost:${PROWLARR_PORT}
      - QBITTORRENT_URL=http://localhost:${NGINX_QBITTORRENT_PORT}
      - PLEX_URL=http://localhost:32400
      - SONARR_URL=http://localhost:${SONARR_PORT}
      - RADARR_URL=http://localhost:${RADARR_PORT}
      - JELLYFIN_URL=http://localhost:${JELLYFIN_PORT}
      - OVERSEERR_URL=http://localhost:${OVERSEERR_PORT:-5055}
      # Backend URLs for internal Docker communication
      - PROWLARR_BACKEND_URL=http://prowlarr:9696
      - QBITTORRENT_BACKEND_URL=http://vpn:8080
      - PLEX_BACKEND_URL=http://docker-host:32400
      - SONARR_BACKEND_URL=http://sonarr:8989
      - RADARR_BACKEND_URL=http://radarr:7878
      - JELLYFIN_BACKEND_URL=http://jellyfin:8096
      - OVERSEERR_BACKEND_URL=http://overseerr:5055
      # Reverse proxy configuration for secure access
      - ENABLE_REVERSE_PROXY=true
      - QBITTORRENT_PROXY_PATH=/qbittorrent
      # API Keys for health checks
      - PROWLARR_API_KEY=${PROWLARR_API_KEY}
      - SONARR_API_KEY=${SONARR_API_KEY}
      - RADARR_API_KEY=${RADARR_API_KEY}
    volumes:
      - ./data/downloads:/downloads
      - ${MEDIA_ROOT:-./data/media}:/media
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    stop_grace_period: 30s
    logging: *default-logging 
  # Prowlarr - Torrent Indexer
  prowlarr:
    image: ghcr.io/linuxserver/prowlarr
    container_name: ${CONTAINER_PREFIX}prowlarr
    entrypoint: ["/scripts/prowlarr-entrypoint.sh"]
    networks:
      - media_network
      - vpn_network
    ports:
      - "${PROWLARR_PORT:-9696}:9696"
    depends_on:
      vpn:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=$(id -u)
      - PGID=$(id -g)
      - TZ=${TZ:-America/New_York}
    volumes:
      - ./config/prowlarr:/config
      - ./config/templates/prowlarr:/templates:ro
      - ./scripts:/scripts:ro
    healthcheck:
      test: ["CMD-SHELL", "curl -f -H \"X-Api-Key: $$PROWLARR_API_KEY\" http://localhost:9696/api/v1/system/status"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    stop_grace_period: 60s
  # Overseerr - Media Request Management
  overseerr:
    build:
      context: .
      dockerfile: overseerr.Dockerfile
    container_name: ${CONTAINER_PREFIX}overseerr
    networks:
      - media_network
      - vpn_network
    ports:
      - "${OVERSEERR_PORT:-5055}:5055"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      plex:
        condition: service_healthy
      radarr:
        condition: service_healthy
      sonarr:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=$(id -u)
      - PGID=$(id -g)
      - TZ=${TZ:-America/New_York}
      - PORT=${OVERSEERR_PORT:-5055}
      - PLEX_TOKEN=${PLEX_TOKEN}
    volumes:
      - ./config/overseerr:/app/config
      - ./config/templates/overseerr:/templates:ro
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:${OVERSEERR_PORT:-5055}/api/v1/status || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    stop_grace_period: 60s
  # External watchdog for comprehensive VPN monitoring (only needed for WARP)
  kill_switch_watchdog:
    image: docker:cli
    container_name: ${CONTAINER_PREFIX}kill_switch_watchdog
    profiles:
      - warp-killswitch
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./scripts:/scripts:ro
      - ./logs:/logs
    entrypoint: ["/scripts/external-vpn-watchdog.sh"]
    environment:
      - CONTAINER_PREFIX=${CONTAINER_PREFIX}
    restart: unless-stopped
    depends_on:
      vpn:
        condition: service_healthy
    networks:
      - default
      - vpn_network
  autoheal:
    image: willfarrell/autoheal:latest
    container_name: ${CONTAINER_PREFIX}autoheal
    restart: unless-stopped
    environment:
      - AUTOHEAL_CONTAINER_LABEL=all # Monitor all containers with healthchecks
      - AUTOHEAL_INTERVAL=${AUTOHEAL_INTERVAL:-5} # Check every 5 seconds
      - AUTOHEAL_START_PERIOD=${AUTOHEAL_START_PERIOD:-60} # Wait 60s before monitoring
      - AUTOHEAL_DEFAULT_STOP_TIMEOUT=${AUTOHEAL_DEFAULT_STOP_TIMEOUT:-10}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    depends_on:
      - vpn
    networks:
      - default
  # Autoscan - Automated library scanning for Plex and Jellyfin
  autoscan:
    image: ghcr.io/niniyas/autoscan:latest
    container_name: ${CONTAINER_PREFIX}autoscan
    networks:
      - media_network # NOT vpn - needs communication with Jellyfin/Plex
    ports:
      - "${AUTOSCAN_PORT:-3030}:3030"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      plex:
        condition: service_healthy
    environment:
      - PUID=$(id -u)
      - PGID=$(id -g)
      - TZ=${TZ:-America/New_York}
      - PLEX_TOKEN="${PLEX_TOKEN}"
    volumes:
      - ./config/autoscan:/config
      - ./config/templates/autoscan:/templates:ro
      - ./scripts:/scripts:ro
      - ${MEDIA_ROOT:-./data/media}:/media
      - ./config/plex:/plex-config:ro
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:3030/autoscan')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    stop_grace_period: 30s
