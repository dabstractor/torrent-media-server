# Custom networks for service isolation
networks:
  media_network:
    driver: bridge
    ipam:
      config:
        - subnet: ${MEDIA_NETWORK_SUBNET}
  vpn_network:
    driver: bridge
    ipam:
      config:
        - subnet: ${VPN_NETWORK_SUBNET}
          ip_range: ${VPN_DHCP_RANGE:-10.233.1.0/24}  # DHCP range excludes static IPs
# Logging configuration
x-logging: &default-logging
  driver: json-file
  options:
    max-size: ${LOG_MAX_SIZE:-10m}
    max-file: ${LOG_MAX_FILE:-3}
# Using local directories instead of Docker volumes for easier management
services:
  # Directory initialization - ensures proper ownership before other services start
  init-directories:
    image: alpine:latest
    container_name: ${CONTAINER_PREFIX}init-directories
    user: "0:0" # Run as root to fix ownership
    command: >
      sh -c "
        mkdir -p /data/media/tv /data/media/movies /data/downloads/complete /data/downloads/incomplete /data/downloads/watch &&
        mkdir -p /data/downloads/complete/radarr /data/downloads/complete/sonarr &&
        chown -R 1000:1000 /data/ &&
        echo 'Directory ownership initialized: 1000:1000'
      "

    volumes:
      - ./data:/data
    restart: "no"
  # VPN Service - Gluetun unified VPN client
  # Supports multiple providers: PIA (native), Cloudflare WARP (custom wireguard)
  # Switch providers by setting VPN_PROVIDER in .env (warp or pia)
  vpn:
    image: qmcgaw/gluetun:latest
    container_name: ${CONTAINER_PREFIX}vpn
    cap_add:
      - NET_ADMIN
    devices:
      - /dev/net/tun:/dev/net/tun
    ports:
      - "${VPN_BITTORRENT_PORT:-16881}:6881" # qBittorrent BitTorrent port
      - "${VPN_BITTORRENT_PORT:-16881}:6881/udp" # qBittorrent BitTorrent port UDP
    environment:
      # Gluetun VPN provider selection
      # For PIA: set VPN_SERVICE_PROVIDER=private internet access (uses OpenVPN)
      # For WARP: set VPN_SERVICE_PROVIDER=custom (uses Wireguard)
      - VPN_SERVICE_PROVIDER=${VPN_SERVICE_PROVIDER:-custom}
      # VPN_TYPE only needed for custom providers (WARP uses wireguard)
      - VPN_TYPE=${VPN_TYPE:-wireguard}

      # Common gluetun settings
      - TZ=${TZ:-America/New_York}
      - FIREWALL=on  # Built-in kill switch
      - DOT=off
      - HEALTH_VPN_DURATION_INITIAL=60s
      - HEALTH_VPN_DURATION_ADDITION=10s

      # Wireguard variables (custom provider for both PIA and WARP)
      # Set WG_* variables in .env based on active provider
      - WIREGUARD_PRIVATE_KEY=${WG_PRIVATE_KEY:-}
      - WIREGUARD_PUBLIC_KEY=${WG_PUBLIC_KEY:-}
      - WIREGUARD_ENDPOINT_IP=${WG_ENDPOINT_IP:-}
      - WIREGUARD_ENDPOINT_PORT=${WG_ENDPOINT_PORT:-}
      - WIREGUARD_ADDRESSES=${WG_ADDRESSES:-}
      - WIREGUARD_PRESHARED_KEY=${WG_PRESHARED_KEY:-}
    networks:
      default:
      vpn_network:
        ipv4_address: ${VPN_IP_ADDRESS}
    volumes:
      # Gluetun state persistence
      - ./config/gluetun:/gluetun
    deploy:
      resources:
        limits:
          memory: ${VPN_MEMORY_LIMIT:-1g}
    healthcheck:
      test: ["CMD", "wget", "-q", "-O", "/dev/null", "http://127.0.0.1:9999"]
      interval: ${VPN_HEALTH_CHECK_INTERVAL:-30s}
      timeout: 10s
      retries: 3
      start_period: 90s
    depends_on:
      startup-coordinator:
        condition: service_started
    restart: unless-stopped
  # FlareSolverr - CloudFlare bypass proxy for Prowlarr indexers
  flaresolverr:
    image: ghcr.io/flaresolverr/flaresolverr:latest
    container_name: ${CONTAINER_PREFIX}flaresolverr
    networks:
      - media_network
    ports:
      - "${FLARESOLVERR_PORT:-18191}:8191"
    depends_on:
      vpn:
        condition: service_healthy
    environment:
      - LOG_LEVEL=info
      - TZ=${TZ:-America/New_York}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8191/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    stop_grace_period: 30s
  # qBittorrent - Torrent download client running through VPN
  qbittorrent:
    image: qbittorrentofficial/qbittorrent-nox:latest
    container_name: ${CONTAINER_PREFIX}qbittorrent
    network_mode: "container:${CONTAINER_PREFIX}vpn" # Share VPN container's network stack (most secure isolation)
    # Port removed - access through Web-UI proxy only
    depends_on:
      init-directories:
        condition: service_completed_successfully
      vpn:
        condition: service_healthy
      startup-coordinator:
        condition: service_started
    environment:
      - TZ=${TZ:-America/New_York}
      - QBT_WEBUI_PORT=${QBITTORRENT_INTERNAL_PORT:-8080}
      - QBT_LEGAL_NOTICE=confirm
      - QBITTORRENT_USERNAME=${QBITTORRENT_USERNAME:-admin}
      - QBITTORRENT_PORT=${QBITTORRENT_PORT:-6881}
    volumes:
      - ./config/qbittorrent:/config
      - ./config/templates/qbittorrent:/templates:ro
      - ./data/downloads:/downloads
      - ./data:/data
      - ./scripts:/scripts:ro
      - ./scripts/qbittorrent-internal-monitor.sh:/scripts/qbittorrent-internal-monitor.sh:ro
      - ./scripts/qbittorrent-wrapper-with-monitor.sh:/scripts/qbittorrent-wrapper-with-monitor.sh:ro
    entrypoint: ["/scripts/qbittorrent-entrypoint.sh"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${QBITTORRENT_INTERNAL_PORT:-8080}"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    profiles:
      - qbittorrent
    restart: unless-stopped
    stop_grace_period: 60s
  # Transmission - Alternative torrent download client running through VPN
  transmission:
    image: lscr.io/linuxserver/transmission:latest
    container_name: ${CONTAINER_PREFIX}transmission
    network_mode: "container:${CONTAINER_PREFIX}vpn" # Share VPN container's network stack (most secure isolation)
    depends_on:
      init-directories:
        condition: service_completed_successfully
      vpn:
        condition: service_healthy
      startup-coordinator:
        condition: service_started
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
      - USER=${TRANSMISSION_USERNAME}
      - PASS=${TRANSMISSION_PASSWORD}
      - PEERPORT=${TRANSMISSION_PORT:-51413}
    volumes:
      - ./config/transmission:/config
      - ./config/templates/transmission:/templates:ro
      - ./data/downloads:/downloads
      - ./data/downloads/watch:/watch
      - ./scripts:/scripts:ro
    entrypoint: ["/scripts/transmission-entrypoint.sh"]
    healthcheck:
      test: ["CMD", "sh", "-c", "curl -s http://localhost:9091/transmission/rpc | grep -q 'X-Transmission-Session-Id'"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    profiles:
      - transmission
    restart: unless-stopped
    stop_grace_period: 60s
  # Plex Media Server
  plex:
    image: ghcr.io/linuxserver/plex
    container_name: ${CONTAINER_PREFIX}plex
    network_mode: host # Required for discovery and direct play
    depends_on:
      init-directories:
        condition: service_completed_successfully
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
      - PLEX_CLAIM=${PLEX_CLAIM_TOKEN}
    volumes:
      - ./config/plex:/config
      - ./config/templates/plex:/templates:ro
      - ${MEDIA_ROOT:-./data/media}:/media
      - ${DOWNLOADS_ROOT:-./data/downloads}:/downloads
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:32400/identity"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
  # Jellyfin Media Server - Open source alternative to Plex
  jellyfin:
    image: ghcr.io/linuxserver/jellyfin:latest
    container_name: ${CONTAINER_PREFIX}jellyfin
    entrypoint: ["/scripts/jellyfin-entrypoint.sh"]
    networks:
      - media_network
    ports:
      - "${JELLYFIN_PORT:-8096}:8096"
      - "${JELLYFIN_HTTPS_PORT:-8920}:8920" # HTTPS port (optional)
      - "${JELLYFIN_DISCOVERY_PORT:-7359}:7359/udp" # Client discovery
      - "${JELLYFIN_DLNA_PORT:-1900}:1900/udp" # DLNA
    depends_on:
      init-directories:
        condition: service_completed_successfully
    env_file:
      - .env
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
      - JELLYFIN_PublishedServerUrl=http://localhost:8096
    volumes:
      - ./config/jellyfin:/config
      - ./config/templates/jellyfin:/templates:ro
      - ./scripts:/scripts:ro
      - ${MEDIA_ROOT}/movies:/data/movies:ro
      - ${MEDIA_ROOT}/tv:/data/tvshows:ro
      - ${DOWNLOADS_ROOT:-./data/downloads}:/downloads:ro
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8096/web/index.html"]
      interval: 60s
      timeout: 15s
      retries: 5
      start_period: 300s
    restart: unless-stopped
    stop_grace_period: 60s
  # Sonarr - TV Series Management
  sonarr:
    image: ghcr.io/linuxserver/sonarr
    container_name: ${CONTAINER_PREFIX}sonarr
    entrypoint: ["/scripts/sonarr-entrypoint.sh"]
    networks:
      - media_network
      - vpn_network
    ports:
      - "${SONARR_PORT:-8989}:8989"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      prowlarr:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
    volumes:
      - ./config/sonarr:/config
      - ./config/templates/sonarr:/templates:ro
      - ./scripts:/scripts:ro
      - ${MEDIA_ROOT:-./data/media}/tv:/tv
      - ./data/downloads:/downloads
    healthcheck:
      test: ["CMD-SHELL", "curl -s http://localhost:8989 > /dev/null 2>&1 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 180s
    restart: unless-stopped
    stop_grace_period: 60s
  # Radarr - Movie Management
  radarr:
    image: ghcr.io/linuxserver/radarr
    container_name: ${CONTAINER_PREFIX}radarr
    entrypoint: ["/scripts/radarr-entrypoint.sh"]
    networks:
      - media_network
      - vpn_network
    ports:
      - "${RADARR_PORT:-7878}:7878"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      prowlarr:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
    volumes:
      - ./config/radarr:/config
      - ./config/templates/radarr:/templates:ro
      - ./scripts:/scripts:ro
      - ${MEDIA_ROOT:-./data/media}/movies:/movies
      - ./data/downloads:/downloads
    healthcheck:
      test: ["CMD-SHELL", "curl -s http://localhost:7878 > /dev/null 2>&1 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 180s
    restart: unless-stopped
    stop_grace_period: 60s
  # Bazarr - Subtitle Automation Service
  bazarr:
    image: lscr.io/linuxserver/bazarr:latest
    container_name: ${CONTAINER_PREFIX}bazarr
    entrypoint: ["/scripts/bazarr-entrypoint.sh"]
    networks:
      - media_network  # NO vpn_network - subtitles downloaded via HTTPS only
    ports:
      - "${BAZARR_PORT:-6767}:6767"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      sonarr:
        condition: service_healthy
      radarr:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
      - SONARR_API_KEY=${SONARR_API_KEY}
      - RADARR_API_KEY=${RADARR_API_KEY}
      - BAZARR_API_KEY=${BAZARR_API_KEY}
    volumes:
      - ./config/bazarr:/config
      - ./config/templates/bazarr:/templates:ro
      - ./scripts:/scripts:ro
      - ${MEDIA_ROOT:-./data/media}/tv:/tv
      - ${MEDIA_ROOT:-./data/media}/movies:/movies
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:6767 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s  # Allow time for config.yaml population
    restart: unless-stopped
    stop_grace_period: 30s
  # Nginx Reverse Proxy - Secure bridge for accessing isolated services
  nginx-proxy:
    image: nginx:alpine
    container_name: ${CONTAINER_PREFIX}nginx-proxy
    networks:
      - media_network
      - vpn_network
    ports:
      - "${NGINX_QBITTORRENT_PORT:-8080}:8080" # qBittorrent proxy
      - "${NGINX_TRANSMISSION_PORT:-9091}:9091" # Transmission proxy
    volumes:
      - ./config/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped
  # Watchlistarr - Plex Watchlist Sync Service
  watchlistarr:
    image: ghcr.io/dabstractor/watchlistarr:latest
    container_name: ${CONTAINER_PREFIX}watchlistarr
    restart: unless-stopped
    networks:
      - media_network
    extra_hosts:
      - "docker-host:host-gateway"
    depends_on:
      sonarr:
        condition: service_healthy
      radarr:
        condition: service_healthy
      plex:
        condition: service_healthy
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
      - PLEX_HOST=${PLEX_HOST}
      - PLEX_PORT=${PLEX_PORT:-32400}
      - PLEX_TOKEN=${PLEX_TOKEN}
      - PLEX_USERNAME=${PLEX_USERNAME}
      - PLEX_PASSWORD=${PLEX_PASSWORD}
      - SONARR_API_KEY=${SONARR_API_KEY}
      - SONARR_BASE_URL=http://sonarr:8989
      - RADARR_API_KEY=${RADARR_API_KEY}
      - RADARR_BASE_URL=http://radarr:7878
    volumes:
      - ./config/watchlistarr:/app/config
      - ./config/templates/watchlistarr:/templates:ro
      - ./scripts:/scripts:ro
      - ./config/plex:/plex-config:ro
    entrypoint: ["/scripts/watchlistarr-entrypoint.sh"]
    healthcheck:
      test: ["CMD", "test", "-f", "/app/config/config.yaml"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    stop_grace_period: 30s
  # Web UI - React frontend for managing the entire stack
  web-ui:
    build: ./web-ui
    container_name: ${CONTAINER_PREFIX}web-ui
    networks:
      - media_network
      - vpn_network
    ports:
      - "${WEB_UI_PORT:-18787}:3000"
    # Run as current user to match file ownership
    user: "1000:1000"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      vpn:
        condition: service_healthy
      plex:
        condition: service_healthy
      prowlarr:
        condition: service_healthy
    environment:
      - NODE_ENV=production
      - PORT=3000
      - WEB_UI_PORT=${WEB_UI_PORT:-18787}
      - NEXT_TELEMETRY_DISABLED=1
      # Frontend URLs for the Services page (user browser access)
      - PROWLARR_URL=http://localhost:${PROWLARR_PORT}
      - QBITTORRENT_URL=http://localhost:${NGINX_QBITTORRENT_PORT}
      - PLEX_URL=http://localhost:32400
      - SONARR_URL=http://localhost:${SONARR_PORT}
      - RADARR_URL=http://localhost:${RADARR_PORT}
      - JELLYFIN_URL=http://localhost:${JELLYFIN_PORT}
      - OVERSEERR_URL=http://localhost:${OVERSEERR_PORT:-5055}
      - JELLYSEER_URL=http://localhost:${JELLYSEER_PORT:-5056}
      - BAZARR_URL=http://localhost:${BAZARR_PORT:-6767}
      # Backend URLs for internal Docker communication
      - PROWLARR_BACKEND_URL=http://prowlarr:9696
      - QBITTORRENT_BACKEND_URL=http://vpn:8080
      - PLEX_BACKEND_URL=http://docker-host:32400
      - SONARR_BACKEND_URL=http://sonarr:8989
      - RADARR_BACKEND_URL=http://radarr:7878
      - JELLYFIN_BACKEND_URL=http://jellyfin:8096
      - OVERSEERR_BACKEND_URL=http://overseerr:5055
      - JELLYSEER_BACKEND_URL=http://jellyseer:5055
      - BAZARR_BACKEND_URL=http://bazarr:6767
      # Reverse proxy configuration for secure access
      - ENABLE_REVERSE_PROXY=true
      - QBITTORRENT_PROXY_PATH=/qbittorrent
      # API Keys for health checks
      - PROWLARR_API_KEY=${PROWLARR_API_KEY}
      - SONARR_API_KEY=${SONARR_API_KEY}
      - RADARR_API_KEY=${RADARR_API_KEY}
    volumes:
      - ./data/downloads:/downloads
      - ${MEDIA_ROOT:-./data/media}:/media
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    stop_grace_period: 30s
    logging: *default-logging 
  # Prowlarr - Torrent Indexer
  prowlarr:
    image: ghcr.io/linuxserver/prowlarr
    container_name: ${CONTAINER_PREFIX}prowlarr
    entrypoint: ["/scripts/prowlarr-entrypoint.sh"]
    networks:
      - media_network
      - vpn_network
    ports:
      - "${PROWLARR_PORT:-9696}:9696"
    depends_on:
      vpn:
        condition: service_healthy
      flaresolverr:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
    volumes:
      - ./config/prowlarr:/config
      - ./config/templates/prowlarr:/templates:ro
      - ./scripts:/scripts:ro
    healthcheck:
      test: ["CMD-SHELL", "curl -f -H \"X-Api-Key: $$PROWLARR_API_KEY\" http://localhost:9696/api/v1/system/status"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    stop_grace_period: 60s
  # Overseerr - Media Request Management
  overseerr:
    build:
      context: .
      dockerfile: overseerr.Dockerfile
    container_name: ${CONTAINER_PREFIX}overseerr
    networks:
      - media_network
      - vpn_network
    ports:
      - "${OVERSEERR_PORT:-5055}:5055"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      plex:
        condition: service_healthy
      radarr:
        condition: service_healthy
      sonarr:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
      - PORT=${OVERSEERR_PORT:-5055}
      - PLEX_TOKEN=${PLEX_TOKEN}
    volumes:
      - ./config/overseerr:/app/config
      - ./config/templates/overseerr:/templates:ro
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:${OVERSEERR_PORT:-5055}/api/v1/status || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    stop_grace_period: 60s
  # Jellyseer - Media request management for Jellyfin
  jellyseer:
    build:
      context: .
      dockerfile: jellyseer.Dockerfile
    container_name: ${CONTAINER_PREFIX}jellyseer
    networks:
      - media_network
      - vpn_network
    ports:
      - "${JELLYSEER_PORT:-5056}:5055"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      jellyfin:
        condition: service_healthy
      radarr:
        condition: service_healthy
      sonarr:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
      - PORT=5055
    volumes:
      - ./config/jellyseer:/app/config
      - ./config/templates/jellyseer:/templates:ro
      - ./scripts:/scripts:ro
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5055/api/v1/status || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    stop_grace_period: 60s
  # External watchdog for comprehensive VPN monitoring (only needed for WARP)
  kill_switch_watchdog:
    image: docker:cli
    container_name: ${CONTAINER_PREFIX}kill_switch_watchdog
    profiles:
      - warp-killswitch
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./scripts:/scripts:ro
      - ./logs:/logs
    entrypoint: ["/scripts/external-vpn-watchdog.sh"]
    environment:
      - CONTAINER_PREFIX=${CONTAINER_PREFIX}
    restart: unless-stopped
    depends_on:
      vpn:
        condition: service_healthy
    networks:
      - default
      - vpn_network
  autoheal:
    image: willfarrell/autoheal:latest
    container_name: ${CONTAINER_PREFIX}autoheal
    restart: unless-stopped
    environment:
      - AUTOHEAL_CONTAINER_LABEL=all # Monitor all containers with healthchecks
      - AUTOHEAL_INTERVAL=${AUTOHEAL_INTERVAL:-5} # Check every 5 seconds
      - AUTOHEAL_START_PERIOD=${AUTOHEAL_START_PERIOD:-60} # Wait 60s before monitoring
      - AUTOHEAL_DEFAULT_STOP_TIMEOUT=${AUTOHEAL_DEFAULT_STOP_TIMEOUT:-10}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    depends_on:
      - vpn
    networks:
      - default
  # Startup Coordinator - Automatically fixes VPN port conflicts after reboot
  startup-coordinator:
    image: docker:cli
    container_name: ${CONTAINER_PREFIX}startup-coordinator
    restart: always # Always restart, even if manually stopped - critical for boot recovery
    network_mode: host # Required to access and kill host port bindings
    environment:
      - CONTAINER_PREFIX=${CONTAINER_PREFIX}
      - VPN_BITTORRENT_PORT=${VPN_BITTORRENT_PORT:-17403}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./scripts/startup-coordinator.sh:/startup-coordinator.sh:ro
    entrypoint: ["/bin/sh", "/startup-coordinator.sh"]
    # No depends_on - must start independently to fix boot issues
  # Autoscan - Automated library scanning for Plex and Jellyfin
  autoscan:
    image: ghcr.io/niniyas/autoscan:latest
    container_name: ${CONTAINER_PREFIX}autoscan
    networks:
      - media_network # NOT vpn - needs communication with Jellyfin/Plex
    ports:
      - "${AUTOSCAN_PORT:-3030}:3030"
    depends_on:
      init-directories:
        condition: service_completed_successfully
      plex:
        condition: service_healthy
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-America/New_York}
      - PLEX_TOKEN="${PLEX_TOKEN}"
    volumes:
      - ./config/autoscan:/config
      - ./config/templates/autoscan:/templates:ro
      - ./scripts:/scripts:ro
      - ${MEDIA_ROOT:-./data/media}:/media
      - ./config/plex:/plex-config:ro
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:3030/autoscan')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    stop_grace_period: 30s
